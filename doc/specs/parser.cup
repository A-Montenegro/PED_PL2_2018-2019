package compiler.syntax;

// Declaraci贸n de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;
import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;
import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaraci贸n del c贸digo de usuario

action code   {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}


// Declaraci贸n de terminales
terminal Token TLTRUE, TLFALSE, TLINT, TLSTRING, TIDENTIFICADOR;
terminal Token TAND, TNOT;
terminal Token TBEGIN, TEND;
terminal Token TIF, TTHEN, TELSE;
terminal Token TMODULE, TPROCEDURE, TRETURN;
terminal Token TDO, TWHILE;
terminal Token TWRITESTRING, TWRITEINT, TWRITELN;
terminal Token TBOOLEAN, TCONST, TINTEGER, TRECORD, TTYPE, TVAR;
terminal Token TPTOCOMA, TPARI, TPARD, TCOMA, TDOSPTS, TIGUAL;
terminal Token TSUMA, TDIVIDE, TASSIGN, TMENOR, TDISTINTO, TPUNTO;




// Declaracin de no terminales
non terminal  									   program;
non terminal 	   Axiom						 	 axiom;

non terminal       CtesLista	         			  ctes;
non terminal       CtesLista	     			 ctesLista;
non terminal       Cte 	          					   cte;
non terminal       CteValor  	    			  cteValor;
non terminal       TiposLista   	     			 tipos;
non terminal       TiposLista     				tiposLista;
non terminal       TypeRecord     	     			  tipo;
non terminal       RegCampos     				  registro;
non terminal       RegCampos     				 regCampos;
non terminal       RegCampo      				  regCampo;
non terminal       VarsLista       		   			  vars;
non terminal       VarsLista     				 varsLista;
non terminal       Var           	  				   var;
non terminal       TypeIF       				   varTipo;
non terminal       String						   subDecl;
non terminal       VarsLista      			     subParams;
non terminal       VarsLista 		   	   subParamsCuerpo;
non terminal       Var     							subPar;
non terminal       TypeSimple  					 subReturn;
non terminal       Sentencias     				sentencias;
non terminal       Sent          					  sent;
non terminal       SentAsign    				 sentAsign;
non terminal       SentES       					sentES;
non terminal       SentReturn   				sentReturn;
non terminal       SentCall     				  sentCall;
non terminal       SentCallParams			sentCallParams;
non terminal       SentIf      						sentIf;
non terminal       Sentencias    				  sentElse;
non terminal       SentWhile   					 sentWhile;
non terminal       Expresion     				 expresion;
non terminal       TypeSimple			 	 tipoPrimitivo;
non terminal       Subs  		  					  subs;
non terminal       CuerpoModulo  			  cuerpoModulo;
non terminal       FinalModulo   			   finalModulo;
non terminal       VarSeqDeIds   		  	   varSeqDeIds;
non terminal       Integer     					 ntPtoComa;


// Declaraci贸n de relaciones de precedencia (de menos a m谩s)
precedence nonassoc TMENOR, TDISTINTO;
precedence left     TSUMA;
precedence left     TDIVIDE, TAND;
precedence right    TNOT;
precedence left     TPUNTO, TPARI, TPARD;


// Declaraci贸n de reglas de producci贸n
// El proceso de an谩lisis ha de empezar emitiendo el mensaje 'Starting parsing...' y
// finalizar emitiendo el mensaje 'Parsing process finished' en el caso de no existir 
// ning煤n error no recuperable.

start with program;

program ::= 
  {: syntaxErrorManager.syntaxInfo ("Starting parsing..."); :}
 
axiom:ax
  {: 
		DireccionamientoMemoria.direccionar(scopeManager, ax);
		// No modificar esta estructura, aunque se pueden a帽adir m谩s acciones sem谩nticas
  		List intermediateCode = ax.getIntermediateCode();
  		System.out.println("\n[CDIGO INTERMEDIO]");
  		for (Object cuadrupla: intermediateCode){
  			System.out.println(cuadrupla); 
  		}
  		finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
  		finalCodeFactory.create (intermediateCode);
  		// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no est谩 completo. Esto es debido a que 
  		// a煤n no se tendr谩 implementada la generaci贸n de c贸digo intermedio ni final.
  		// Para la entrega final deber谩n descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
  :}
  
  ;

axiom ::=
        TMODULE TIDENTIFICADOR:id  ntPtoComa:pc   {:
        	//Operaciones y comprobaciones semnticas:
        	String nombreAmbito= id.getLexema().toUpperCase();
        	scopeManager.openScope(nombreAmbito);
        	OperacionSemantica operacionSemantica= new OperacionSemantica();
        	operacionSemantica.inicializarTablaTipos();
        	operacionSemantica.getErrorSemantico().lanzarInfoAmbitoGlobal(nombreAmbito, pc);
			
        :} cuerpoModulo:cModulo  {:
        	//Operaciones y comprobaciones semnticas:
        	int numeroLinea= cModulo.getFinalModulo().getNumeroLinea();
        	ErrorSemantico errorSemantico= new ErrorSemantico();
        	if(!cModulo.getFinalModulo().getNombreModulo().equals(scopeManager.getScope(0).getName())) errorSemantico.lanzarErrorPorAmbitoCerradoConNombreIcorrecto(numeroLinea);
        	
        	//Cdigo intermedio:
        	ScopeIF scope= scopeManager.getCurrentScope();
        	String nombre= scope.getName();
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	cb.addQuadruples(cModulo.getCodigoIntermedioTotal());
        	Axiom ax= new AxiomImpl(cb.create());
    		scopeManager.closeScope();
			errorSemantico.lanzarInfoCierreAmbito(nombre,numeroLinea);
			RESULT= ax;
         :}
        | TMODULE error
            
    ;


//
// DEFINICIN DE CONSTANTES
//
ctes ::=
        TCONST ctesLista:cLista {: RESULT= cLista; :}
        
        | /*nada*/          
    ;

ctesLista ::=
        cte:c ctesLista:cLista {:
        	cLista.addCte(c);
			RESULT= cLista;
        :}
         
        | cte:c {: RESULT= new CtesLista(c); :}   
    ;

cte ::=
        TIDENTIFICADOR:id TIGUAL cteValor:cv ntPtoComa:pc {:
        		//Operaciones y comprobaciones semnticas:
        		String nombre= id.getLexema().toUpperCase();
				Cte cte=new Cte(nombre,cv);
				OperacionSemantica operacionSemantica= new OperacionSemantica();
				operacionSemantica.addSimboloTablaSimbolos(nombre, cv.getTipoValor(), 0, pc);
				SymbolConstant simbolo= (SymbolConstant)operacionSemantica.recuperarSimboloDesdeTablaSimbolos(nombre, pc);
				simbolo.setValor(cv.getValor());
				RESULT=cte;
		   :}  
		            
		   | error	            
    ;


cteValor ::=
        TLTRUE:t 	{: 
        	TypeSimple tipo= (TypeSimple)scopeManager.searchType("LOGICO");
        	RESULT=new CteValor(t.getLexema().toUpperCase(), tipo); 
        :}      
        | TLFALSE:t {: 
        	TypeSimple tipo= (TypeSimple)scopeManager.searchType("LOGICO");
        	RESULT=new CteValor(t.getLexema().toUpperCase(), tipo); 
        :}             
        | TLINT:t {: 
        	TypeSimple tipo= (TypeSimple)scopeManager.searchType("ENTERO");
        	RESULT=new CteValor(t.getLexema(), tipo); 
        :}      
    ;


//
// DEFINICIN DE TIPOS
//
tipos ::=
        TTYPE tiposLista:tpLista {: RESULT= tpLista; :}
        | /*nada*/
	;
 
tiposLista ::= tipo:tp tiposLista:tpLista {:
		tpLista.addTipo(tp);
		RESULT= tpLista;
	:}            
        | tipo:tp {: RESULT= new TiposLista(tp); :}
	;

tipo ::= TIDENTIFICADOR:id TIGUAL registro:rg ntPtoComa:pc {:
			//Operaciones y comprobaciones semnticas:
			TypeRecord typeRecord= new TypeRecord(scopeManager.getCurrentScope(),id.getLexema(), rg);
			OperacionSemantica operacionSemantica= new OperacionSemantica();
			operacionSemantica.addTipoTablaTipos(typeRecord, pc);
			RESULT= typeRecord;
	:}
        | error
            
    ;

registro ::=
        TRECORD regCampos:rc TEND {: RESULT=rc; :}
        | error
            
    ;

regCampos ::=
        regCampo:rc regCampos:rcs {:
            rcs.addRegCampo(rc);
            RESULT= rcs;
        :}
        | regCampo:rc {: RESULT= new RegCampos(rc); :}
    ;

regCampo ::=
        TIDENTIFICADOR:id TDOSPTS tipoPrimitivo:tp ntPtoComa:pc {: RESULT= new RegCampo(id.getLexema(), tp, pc); :}   
        | error
            
    ;


//
// DEFINICIN DE VARIABLES
//

vars ::=
        TVAR varsLista:vLista {: RESULT= vLista; :}   
        | /*Nada*/          
    ;

varsLista ::=
        var:v varsLista:vLista {:
        	vLista.addVar(v);
        	RESULT= vLista;
        :}
            
        | var:v {: RESULT= new VarsLista(v); :}
             
    ;

var ::=
        varSeqDeIds:vsids TDOSPTS varTipo:vt ntPtoComa:pc{:
        	//Operaciones y comprobaciones semnticas:
			Var var=new Var(vsids, vt);
			OperacionSemantica operacionSemantica= new OperacionSemantica();
			operacionSemantica.addSecuenciaSimbolosTablaSimbolos(vsids,vt,1,pc);
			RESULT=var;
        :}
            
        | error
            
    ;

varTipo ::=
        tipoPrimitivo:tp {: RESULT= tp; :}
        | TIDENTIFICADOR:id  {:
        	//Operaciones y comprobaciones semnticas:
        	OperacionSemantica operacionSemantica= new OperacionSemantica();
        	TypeIF tipo= operacionSemantica.recuperarTipoDesdeTablaTipos(id.getLexema().toUpperCase(),id.getLine());
        	RESULT= tipo;
        :}
    ;


//
// DEFINICIN DE SUBPROGRAMAS
//

subs ::=
        subs:subs TPROCEDURE subDecl:sD cuerpoModulo:cM {:
        	//Operaciones y comprobaciones semnticas:
        	ErrorSemantico errorSemantico= new ErrorSemantico();
        	int numeroLinea= cM.getFinalModulo().getNumeroLinea();
        	if(!sD.equals(cM.getFinalModulo().getNombreModulo())) errorSemantico.lanzarErrorPorAmbitoCerradoConNombreIcorrecto(numeroLinea);
        	subs.addCuerpoModulo(cM);
			RESULT= subs;
		:}
            
        | {: RESULT= new Subs(); :} //Nada
            
    ;

subDecl ::= TIDENTIFICADOR:id subParams:sP subReturn:sReturn ntPtoComa:pc {:
			//Operaciones y comprobaciones semnticas:
			String nombre= id.getLexema().toUpperCase();
			LabelFactory lF = new LabelFactory();
			LabelIF l1 = lF.create();
			OperacionSemantica operacionSemantica= new OperacionSemantica();
			if (operacionSemantica.existeProcedimientoEnAmbito(nombre)) operacionSemantica.getErrorSemantico().lanzarErrorPorProcedimientoDuplicado(pc);
			if(sReturn==null){
				TypeProcedure tipoProcedimiento= new TypeProcedure(scopeManager.getCurrentScope(), nombre, sP);
				tipoProcedimiento.setLabel(l1);
				operacionSemantica.addTipoTablaTipos(tipoProcedimiento,pc);
				operacionSemantica.addSimboloTablaSimbolos(nombre, tipoProcedimiento, 3, pc);
			}else{
				TypeFunction tipoFuncion= new TypeFunction(scopeManager.getCurrentScope(), nombre, sP, sReturn);
				tipoFuncion.setLabel(l1);
				operacionSemantica.addTipoTablaTipos(tipoFuncion,pc);
				operacionSemantica.addSimboloTablaSimbolos(nombre, tipoFuncion, 4, pc);
			}	
			scopeManager.openScope(nombre);
			operacionSemantica= new OperacionSemantica();
			operacionSemantica.getErrorSemantico().lanzarInfoNuevoAmbitoAbierto(nombre, pc);
			operacionSemantica.addSecuenciaParametrosTablaSimbolos(sP,pc);
			operacionSemantica.addSimbolosParametrosASimboloProcedimiento(sP);
			RESULT= nombre;
        :}    
            
        | error
            
     ;

subParams ::= 
        TPARI TPARD {: RESULT= new VarsLista(); :}                          
        | TPARI subParamsCuerpo:sPC TPARD  {: RESULT= sPC; :} 
        | /*nada*/  {: RESULT= new VarsLista(); :}                          
    ;

subParamsCuerpo ::=
        subPar:sP ntPtoComa subParamsCuerpo:sPC {:
        	sPC.addVar(sP);
        	RESULT= sPC;
        :}
         	   
        | subPar:sP {: RESULT= new VarsLista(sP); :}       
    ;

subPar ::= 
        TVAR varSeqDeIds:vsids TDOSPTS:tdospts varTipo:vTipo {: RESULT= new Var(vsids, vTipo); :}  
        | error
            
    ;

subReturn ::=
        TDOSPTS tipoPrimitivo:tp {: RESULT= tp; :}
            
        | {: RESULT= null; :} //Nada
            
        | error
            
    ;



//
// DEFINICIN DE SENTENCIAS
//

sentencias ::= 
        sent:sent ntPtoComa sentencias:sents {:
        	//Operaciones y comprobaciones semnticas:
        	sents.addSentencia(sent);
        	
        	//Cdigo intermedio:
        	ScopeIF scope= scopeManager.getCurrentScope();
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	cb.addQuadruples(sent.getIntermediateCode());
        	cb.addQuadruples(sents.getIntermediateCode());
        	sents.setIntermediateCode(cb.create());
        	RESULT= sents;
        :}  
        | /*Nada*/ {: RESULT= new Sentencias(); :}
            
        | error
            
    ;

sent ::= sentAsign:s {: RESULT=s; :}        
        | sentES:s {: RESULT=s; :}
        | sentReturn:s {: RESULT=s; :}
        | sentIf:s {: RESULT=s; :}  TEND       
        | sentWhile:s {: RESULT=s; :}  TEND    
        | sentCall:s {: RESULT=s; :} 
        | error
            
    ;

sentAsign ::=
        TIDENTIFICADOR:id TASSIGN:tassign expresion:exp {:
        //Operaciones y comprobaciones semnticas:
        String idVariable= id.getLexema().toUpperCase();
        OperacionSemantica operacionSemantica= new OperacionSemantica();
        SymbolIF simbolo= operacionSemantica.recuperarSimboloDesdeTablaSimbolos(idVariable, tassign.getLine());
        TypeSimple tipoSimbolo= operacionSemantica.recuperarTipoSimplePorNombre(idVariable, tassign.getLine());
        if(!((simbolo instanceof SymbolVariable) || (simbolo instanceof SymbolParameter))){
        	 operacionSemantica.getErrorSemantico().lanzarErrorPorSentenciaAsignacionAConstante(tassign.getLine());
        }
        if(!tipoSimbolo.compararNombre(exp.getTipoExpresion()))   operacionSemantica.getErrorSemantico().lanzarErrorPorSentenciaAsignacionIncorrecta(tassign.getLine());
        
        //Cdigo intermedio:
        ScopeIF scope= scopeManager.getCurrentScope();
    	TemporalFactory tf= new TemporalFactory(scope);
    	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
    	TemporalIF temp= tf.create();
    	TemporalIF eTemp= exp.getTemporal();
    	cb.addQuadruples(exp.getIntermediateCode());
    	Variable var= new Variable(idVariable, simbolo.getScope());
    	cb.addQuadruple("MVA", temp, var);
    	cb.addQuadruple("STP", temp, eTemp);
    	SentAsign sentAsign= new SentAsign(idVariable, exp);
    	sentAsign.setIntermediateCode(cb.create());
    	RESULT= sentAsign;
        :}  
          
        | TIDENTIFICADOR:id TPUNTO TIDENTIFICADOR:idRegCampo TASSIGN:tassign expresion:exp  {:
        //Operaciones y comprobaciones semnticas:
        String idVariableRegistro= id.getLexema().toUpperCase();
        OperacionSemantica operacionSemantica= new OperacionSemantica();
        TypeRecord tipoRegistro= operacionSemantica.recuperarTipoRegistroPorNombreDelSimbolo(idVariableRegistro, tassign.getLine());
		RegCampo regCampo=tipoRegistro.recuperarRegCampoPorNombre(idRegCampo.getLexema().toUpperCase());
		if (regCampo==null) operacionSemantica.getErrorSemantico().lanzarErrorPorNoExistirRegCampo(tassign.getLine());
		TypeSimple tipoRegCampo=regCampo.getTipoPrimitivoVariable();
		TypeIF tipoExpresion= exp.getTipoExpresion();
        if(!tipoRegCampo.compararNombre(tipoExpresion)){
        	operacionSemantica.getErrorSemantico().lanzarErrorPorSentenciaAsignacionIncorrecta(tassign.getLine());
        }
        String nombreVariable= idVariableRegistro +"."+idRegCampo.getLexema().toUpperCase();
        
        //Cdigo intermedio:
        ScopeIF scope= scopeManager.getCurrentScope();
    	TemporalFactory tf= new TemporalFactory(scope);
    	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
    	TemporalIF temp1= tf.create();
    	TemporalIF eTemp= exp.getTemporal();
    	cb.addQuadruples(exp.getIntermediateCode());
    	int posicion= tipoRegistro.getPosicion(regCampo.getNombreVariable());
        SymbolIF simboloRegistro= scopeManager.searchSymbol(idVariableRegistro);
    	Variable var= new Variable(idVariableRegistro, simboloRegistro.getScope());
        cb.addQuadruple("MVA", temp1, var, posicion);
    	cb.addQuadruple("STP", temp1, eTemp);
    	SentAsign sentAsign= new SentAsign(nombreVariable, exp);
    	sentAsign.setIntermediateCode(cb.create());
    	RESULT= sentAsign;
        :}  
            
    ;

sentWhile ::= TWHILE expresion:exp TDO:tdo sentencias:sents {:
				//Operaciones y comprobaciones semnticas:
			 	TypeSimple tipo= exp.getTipoExpresion();
			 	if(!tipo.getName().equals("LOGICO")) {
			 		ErrorSemantico errorSemantico= new ErrorSemantico();
			 		errorSemantico.lanzarErrorPorSentenciaWhileIncorrecta(tdo.getLine());
			 	}
			 	
			 	//Cdigo intermedio:
			 	ScopeIF scope= scopeManager.getCurrentScope();
	    		LabelFactoryIF lF= new LabelFactory();
	    		LabelIF l1= lF.create();
	    		LabelIF l2= lF.create();
	    		TemporalIF eTemp= exp.getTemporal();
	    		IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
	    		cb.addQuadruple ("INL", l1);
	    		cb.addQuadruples (exp.getIntermediateCode());
	    		cb.addQuadruple("BRF", eTemp, l2);
	    		cb.addQuadruples (sents.getIntermediateCode());
	    		cb.addQuadruple("BR", l1);
	    		cb.addQuadruple("INL", l2);
	    		SentWhile sentWhile= new SentWhile(sents);
	    		sentWhile.setIntermediateCode(cb.create());
	    		RESULT= sentWhile;
		:}
	;

sentIf ::=  TIF expresion:exp TTHEN:tthen sentencias:sents sentElse:sentsElse {:
			//Operaciones y comprobaciones semnticas:
		 	TypeSimple tipo= exp.getTipoExpresion();
		 	if(!tipo.getName().equals("LOGICO")) {
		 		ErrorSemantico errorSemantico= new ErrorSemantico();
		 		errorSemantico.lanzarErrorPorSentenciaIfIncorrecta(tthen.getLine());
		 	}
		 	
		 	//Cdigo intermedio:
		 	ScopeIF scope= scopeManager.getCurrentScope();
    		LabelFactoryIF lF= new LabelFactory();
    		LabelIF l1= lF.create();
    		LabelIF l2= lF.create();
    		TemporalIF expTemp= exp.getTemporal();
    		IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
    		cb.addQuadruples(exp.getIntermediateCode());
    		cb.addQuadruple("BRF",expTemp, l1);
    		cb.addQuadruples(sents.getIntermediateCode());
    		cb.addQuadruple("BR", l2);
    		cb.addQuadruple("INL", l1);
    		cb.addQuadruples(sentsElse.getIntermediateCode());
    		cb.addQuadruple("INL", l2);
    		SentIf sentIf= new SentIf(sents,sentsElse);
    		sentIf.setIntermediateCode(cb.create());
    		RESULT= sentIf;
		:}
	;

sentElse ::=
        TELSE sentencias:s {: RESULT= s; :}
        | /*Nada*/ {: RESULT= new Sentencias(); :}
            
    ;

sentES ::=
        TWRITESTRING TPARI TLSTRING:tlstring TPARD {: 
        	//Cdigo intermedio:
            ScopeIF scope= scopeManager.getCurrentScope();
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	LabelFactory lF= new LabelFactory();
        	LabelIF l1= lF.create();
        	cb.addQuadruple("PRINTC",l1);
        	cb.addQuadruple("CADENA",tlstring.getLexema(), l1);
			SentES sentES= new SentES("TWRITESTRING",tlstring.getLexema()); 
			sentES.setIntermediateCode(cb.create());
        	RESULT= sentES; 
        :}   
        
        | TWRITEINT TPARI expresion:exp TPARD:tpard {:
        	//Operaciones y comprobaciones semnticas:
		 	TypeSimple tipo= exp.getTipoExpresion();
		 	if(!tipo.getName().equals("ENTERO")) {
		 		ErrorSemantico errorSemantico= new ErrorSemantico();
		 		errorSemantico.lanzarErrorPorSentenciaWriteIntIncorrecta(tpard.getLine());
		 	}
		 	
		 	//Cdigo intermedio:
		 	ScopeIF scope= scopeManager.getCurrentScope();
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	TemporalIF temp= exp.getTemporal();
        	cb.addQuadruples(exp.getIntermediateCode());
        	cb.addQuadruple("PRINTI", temp);
			SentES sentES= new SentES("TWRITEINT"); 
			sentES.setIntermediateCode(cb.create());
        	RESULT= sentES; 
		:}  
		
        | TWRITELN   {: 
        	//Cdigo intermedio:
        	ScopeIF scope= scopeManager.getCurrentScope();
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	cb.addQuadruple("PRINTLN");
			SentES sentES= new SentES("TWRITELN"); 
			sentES.setIntermediateCode(cb.create());
        	RESULT= sentES;
        :}                         
    ;

sentReturn ::=
        TRETURN:treturn expresion:exp {:
        	//Operaciones y comprobaciones semnticas:
        	TypeSimple tipoExpresion= exp.getTipoExpresion();
        	OperacionSemantica operacionSemantica=new OperacionSemantica();
        	operacionSemantica.validarSentenciaReturn(tipoExpresion, treturn.getLine());
        	
        	//Cdigo intermedio:
        	ScopeIF scope= scopeManager.getCurrentScope();
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
			TemporalIF temp = exp.getTemporal();
			cb.addQuadruples(exp.getIntermediateCode ());
			cb.addQuadruple("RETURN", temp);
			SentReturn sentReturn= new SentReturn(tipoExpresion);
			sentReturn.setIntermediateCode(cb.create());
			RESULT = sentReturn;
        :}
            
    ;

sentCall ::=
        TIDENTIFICADOR:idTipoProcedimiento TPARI sentCallParams:param TPARD:tpard {:
        	//Operaciones y comprobaciones semnticas:
        	String nombreID= idTipoProcedimiento.getLexema().toUpperCase();
        	OperacionSemantica operacionSemantica= new OperacionSemantica();
        	TypeProcedure tipoProcedimiento= operacionSemantica.recuperarTipoProcedimientoPorNombre(nombreID, tpard.getLine());
        	if (tipoProcedimiento instanceof TypeFunction) operacionSemantica.getErrorSemantico().lanzarErrorPorNoSerTipoProcedimiento(tpard.getLine());
        	tipoProcedimiento.comprobarCoincidenciaTiposParametros(param.getPilaTipos(), tpard.getLine());
        	
        	//Cdigo intermedio:
        	ScopeIF scope= scopeManager.getCurrentScope();
        	LabelIF l1=tipoProcedimiento.getLabel();
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
			cb.addQuadruples(param.getIntermediateCode());
        	cb.addQuadruple("CALL", l1, nombreID);
        	SentCall sentCall= new SentCall(tipoProcedimiento); 
        	sentCall.setIntermediateCode(cb.create());
        	RESULT= sentCall;
        :}  
        
        | TIDENTIFICADOR:idTipoProcedimiento {:
        	//Operaciones y comprobaciones semnticas:
        	String nombreID= idTipoProcedimiento.getLexema().toUpperCase();
        	OperacionSemantica operacionSemantica= new OperacionSemantica();
        	TypeProcedure tipoProcedimiento= operacionSemantica.recuperarTipoProcedimientoPorNombre(nombreID, idTipoProcedimiento.getLine());
        	if (tipoProcedimiento instanceof TypeFunction) operacionSemantica.getErrorSemantico().lanzarErrorPorNoSerTipoProcedimiento(idTipoProcedimiento.getLine());
        	tipoProcedimiento.comprobarCoincidenciaTiposParametros(new Stack<TypeIF>(), idTipoProcedimiento.getLine());  
        	    	
        	//Cdigo intermedio:
        	ScopeIF scope= scopeManager.getCurrentScope();
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	LabelIF l1= tipoProcedimiento.getLabel();
        	cb.addQuadruple("CALL", l1, nombreID);
        	SentCall sentCall= new SentCall(tipoProcedimiento); 
        	sentCall.setIntermediateCode(cb.create());
        	RESULT= sentCall;
        :}                             
    ;

sentCallParams ::= 
        TIDENTIFICADOR:id {:
        	//Operaciones y comprobaciones semnticas:
        	String nombreID= id.getLexema().toUpperCase();
        	OperacionSemantica operacionSemantica= new OperacionSemantica();
        	SymbolIF simbolo=operacionSemantica.recuperarSimboloDesdeTablaSimbolos(nombreID, id.getLine());
        	TypeIF tipoSimbolo;
        	TypeFunction tipoFuncion;
        	if(simbolo instanceof SymbolFunction){
        		tipoFuncion= (TypeFunction)simbolo.getType();
        		tipoSimbolo= tipoFuncion.getTipoFuncion();
        	}else{
        		tipoSimbolo= simbolo.getType();
        	}
        	
        	//Cdigo intermedio:
        	ScopeIF scope= scopeManager.getCurrentScope();
        	TemporalFactory tf= new TemporalFactory(scope);
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	TemporalIF temp= tf.create();	
        	if (simbolo instanceof SymbolConstant){
        		operacionSemantica.getErrorSemantico().lanzarErrorPorInvocacionConParametrosIncorrectos(id.getLine());
        	}else if(simbolo instanceof SymbolVariable || simbolo instanceof SymbolParameter){
        		if(simbolo.getType() instanceof TypeRecord){
        			TemporalIF[] temps = new TemporalIF[simbolo.getType().getSize()];
        			for(int i = 0; i < simbolo.getType().getSize(); i++){
        				Variable var= new Variable(nombreID,simbolo.getScope());
        				if(i==0){
        					temps[i]=temp;
        				}else{
        					temps[i]= tf.create();
        				}
        				cb.addQuadruple("MVA", temps[i], var, i);
        				cb.addQuadruple("PARAM", temps[i]);
        			}
        		}else{
        			Variable var= new Variable(nombreID,simbolo.getScope());
        			cb.addQuadruple("MVA", temp, var);
        			cb.addQuadruple("PARAM", temp);
        		}
        	}
        	else{
	        	operacionSemantica.getErrorSemantico().lanzarErrorPorInvocacionConParametrosIncorrectos(id.getLine());
        	}
        	SentCallParams sentCallParams= new SentCallParams(tipoSimbolo);
        	sentCallParams.setIntermediateCode(cb.create());
        	RESULT= sentCallParams;
        :}
            
        | TIDENTIFICADOR:id TCOMA:tcoma sentCallParams:sCP {:
        	//Operaciones y comprobaciones semnticas:
        	String nombreID= id.getLexema().toUpperCase();
        	OperacionSemantica operacionSemantica= new OperacionSemantica();
        	SymbolIF simbolo=operacionSemantica.recuperarSimboloDesdeTablaSimbolos(nombreID, id.getLine());
        	TypeIF tipoSimbolo;
        	TypeFunction tipoFuncion;
        	if(simbolo instanceof SymbolFunction){
        		tipoFuncion= (TypeFunction)simbolo.getType();
        		tipoSimbolo= tipoFuncion.getTipoFuncion();
        	}else{
        		tipoSimbolo= simbolo.getType();
        	}
        	sCP.addTipo(tipoSimbolo);
        	
        	//Cdigo intermedio:
        	ScopeIF scope= scopeManager.getCurrentScope();
        	TemporalFactory tf= new TemporalFactory(scope);
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	TemporalIF temp= tf.create();	
        	if (simbolo instanceof SymbolConstant){
        		operacionSemantica.getErrorSemantico().lanzarErrorPorInvocacionConParametrosIncorrectos(id.getLine());
        	}else if(simbolo instanceof SymbolVariable || simbolo instanceof SymbolParameter){
        		if(simbolo.getType() instanceof TypeRecord){
        			TemporalIF[] temps = new TemporalIF[simbolo.getType().getSize()];
        			for(int i = 0; i < simbolo.getType().getSize(); i++){
        				Variable var= new Variable(nombreID,simbolo.getScope());
        				if(i==0){
        					temps[i]=temp;
        				}else{
        					temps[i]= tf.create();
        				}
        				cb.addQuadruple("MVA", temps[i], var, i);
        				cb.addQuadruple("PARAM", temps[i]);
        			}
        		}else{
        			Variable var= new Variable(nombreID,simbolo.getScope());
        			cb.addQuadruple("MVA", temp, var);
        			cb.addQuadruple("PARAM", temp);
        		}
        	}
        	else{
	        	operacionSemantica.getErrorSemantico().lanzarErrorPorInvocacionConParametrosIncorrectos(id.getLine());
        	}
        	cb.addQuadruples(sCP.getIntermediateCode());
        	sCP.setIntermediateCode(cb.create());
        	RESULT= sCP;
        :}
            
        | TIDENTIFICADOR:id TPUNTO:tpunto TIDENTIFICADOR:idRegCampo {:
        	//Operaciones y comprobaciones semnticas:
        	String idTipoRegistro= id.getLexema().toUpperCase();
        	OperacionSemantica operacionSemantica= new OperacionSemantica();
        	TypeRecord tipoRegistro= operacionSemantica.recuperarTipoRegistroPorNombreDelSimbolo(idTipoRegistro, tpunto.getLine());
			RegCampo regCampo=tipoRegistro.recuperarRegCampoPorNombre(idRegCampo.getLexema().toUpperCase());
			if (regCampo==null) operacionSemantica.getErrorSemantico().lanzarErrorPorNoExistirRegCampo(tpunto.getLine());
			TypeSimple tipoRegCampo=regCampo.getTipoPrimitivoVariable();
			
			
			//Cdigo intermedio:
			ScopeIF scope= scopeManager.getCurrentScope();
        	TemporalFactory tf= new TemporalFactory(scope);
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	TemporalIF temp= tf.create();
        	int posicion= tipoRegistro.getPosicion(regCampo.getNombreVariable());
        	SymbolIF sV= scopeManager.searchSymbol(idTipoRegistro);
        	Variable var= new Variable(idTipoRegistro, sV.getScope());
        	cb.addQuadruple("MVA", temp, var, posicion);
        	cb.addQuadruple("PARAM", temp);
        	SentCallParams sentCallParams= new SentCallParams(tipoRegCampo);
        	sentCallParams.setIntermediateCode(cb.create());
			RESULT= sentCallParams;
        :}
            
        | TIDENTIFICADOR:id TPUNTO TIDENTIFICADOR:idRegCampo TCOMA:tcoma sentCallParams:sCP {:
        	//Operaciones y comprobaciones semnticas:
        	String idTipoRegistro= id.getLexema().toUpperCase();
        	OperacionSemantica operacionSemantica= new OperacionSemantica();
        	TypeRecord tipoRegistro= operacionSemantica.recuperarTipoRegistroPorNombreDelSimbolo(idTipoRegistro, tcoma.getLine());
			RegCampo regCampo=tipoRegistro.recuperarRegCampoPorNombre(idRegCampo.getLexema().toUpperCase());
			if (regCampo==null) operacionSemantica.getErrorSemantico().lanzarErrorPorNoExistirRegCampo(tcoma.getLine());
			TypeSimple tipoRegCampo=regCampo.getTipoPrimitivoVariable();
			sCP.addTipo(tipoRegCampo);
			
			//Cdigo intermedio:
			ScopeIF scope= scopeManager.getCurrentScope();
        	TemporalFactory tf= new TemporalFactory(scope);
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	TemporalIF temp= tf.create();
        	int posicion= tipoRegistro.getPosicion(regCampo.getNombreVariable());
        	SymbolIF sV= scopeManager.searchSymbol(idTipoRegistro);
        	Variable var= new Variable(idTipoRegistro, sV.getScope());
        	cb.addQuadruples(sCP.getIntermediateCode());
        	cb.addQuadruple("MVA", temp, var, posicion);
        	cb.addQuadruple("PARAM", temp);
        	sCP.setIntermediateCode(cb.create());
			RESULT= sCP;
        :}
            
        | /*Nada*/ {: RESULT= new SentCallParams(); :}
            
        | error
            
    ;

expresion ::=
        TNOT:tnot expresion:exp {: 
        	//Comprobaciones semnticas y cdigo intermedio:
	        ScopeIF scope= scopeManager.getCurrentScope();
	    	TemporalFactory tf= new TemporalFactory(scope);
	    	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
			TemporalIF temp1 = exp.getTemporal ();
			TemporalIF temp = tf.create ();
			cb.addQuadruples (exp.getIntermediateCode());
			cb.addQuadruple ("NOT", temp, temp1);
	        Expresion expresion= exp.operadorLogicoNOT(tnot.getLine()); 
	        expresion.setTemporal (temp);
			expresion.setIntermediateCode (cb.create());
	        RESULT= expresion;
        :}  
                          
        | TPARI expresion:exp TPARD {: RESULT= exp; :} 
                    
        | expresion:exp1 TDIVIDE:tdivide expresion:exp2 {: 
        	//Comprobaciones semnticas y cdigo intermedio:
        	ScopeIF scope= scopeManager.getCurrentScope();
        	TemporalFactory tf= new TemporalFactory(scope);
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	TemporalIF temp1= exp1.getTemporal();
        	TemporalIF temp2= exp2.getTemporal();
        	TemporalIF temp= tf.create();
        	cb.addQuadruples(exp1.getIntermediateCode());
        	cb.addQuadruples(exp2.getIntermediateCode());
        	cb.addQuadruple("DIV",temp,temp1,temp2);
        	Expresion expresion= exp1.operadorDividir(exp2, tdivide.getLine());
        	expresion.setTemporal(temp);
        	expresion.setIntermediateCode (cb.create());
        	RESULT= expresion;
        :}  
        
        | expresion:exp1 TSUMA:tsuma expresion:exp2 {: 
        	//Comprobaciones semnticas y cdigo intermedio:
            ScopeIF scope= scopeManager.getCurrentScope();
        	TemporalFactory tf= new TemporalFactory(scope);
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	TemporalIF temp1= exp1.getTemporal();
        	TemporalIF temp2= exp2.getTemporal();
        	TemporalIF temp= tf.create();
        	cb.addQuadruples(exp1.getIntermediateCode());
        	cb.addQuadruples(exp2.getIntermediateCode());
        	cb.addQuadruple("ADD",temp,temp1,temp2);
        	Expresion expresion= exp1.operadorSuma(exp2, tsuma.getLine());
        	expresion.setTemporal(temp);
        	expresion.setIntermediateCode (cb.create());
        	RESULT= expresion;
        :} 
           
        | expresion:exp1 TAND:tand expresion:exp2 {: 
        	//Comprobaciones semnticas y cdigo intermedio:
            ScopeIF scope= scopeManager.getCurrentScope();
        	TemporalFactory tf= new TemporalFactory(scope);
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	TemporalIF temp1= exp1.getTemporal();
        	TemporalIF temp2= exp2.getTemporal();
        	TemporalIF temp= tf.create();
        	cb.addQuadruples(exp1.getIntermediateCode());
        	cb.addQuadruples(exp2.getIntermediateCode());
        	cb.addQuadruple("AND",temp,temp1,temp2);
        	Expresion expresion= exp1.operadorLogicoAND(exp2, tand.getLine());
        	expresion.setTemporal(temp);
        	expresion.setIntermediateCode (cb.create());
        	RESULT= expresion;
        :}   
        
        | expresion:exp1 TMENOR:tmenor expresion:exp2 {: 
        	//Comprobaciones semnticas y cdigo intermedio:
            ScopeIF scope= scopeManager.getCurrentScope();
        	TemporalFactory tf= new TemporalFactory(scope);
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	TemporalIF temp1= exp1.getTemporal();
        	TemporalIF temp2= exp2.getTemporal();
        	TemporalIF temp= tf.create();
        	cb.addQuadruples(exp1.getIntermediateCode());
        	cb.addQuadruples(exp2.getIntermediateCode());
        	cb.addQuadruple("LS",temp,temp1,temp2);
        	Expresion expresion= exp1.operadorMenorQue(exp2, tmenor.getLine());
        	expresion.setTemporal(temp);
        	expresion.setIntermediateCode (cb.create());
        	RESULT= expresion;
        :}
           
        | expresion:exp1 TDISTINTO:tdistinto expresion:exp2 {: 
        	//Comprobaciones semnticas y cdigo intermedio:
        	ScopeIF scope= scopeManager.getCurrentScope();
        	TemporalFactory tf= new TemporalFactory(scope);
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	TemporalIF temp2= exp1.getTemporal();
        	TemporalIF temp3= exp2.getTemporal();
        	TemporalIF temp1= tf.create();
        	TemporalIF temp= tf.create();
        	cb.addQuadruples(exp1.getIntermediateCode());
        	cb.addQuadruples(exp2.getIntermediateCode());
        	cb.addQuadruple("EQ",temp1,temp2,temp3);
        	cb.addQuadruple ("NOT", temp, temp1);
        	Expresion expresion= exp1.operadorDistintoQue(exp2, tdistinto.getLine());
        	expresion.setTemporal(temp);
        	expresion.setIntermediateCode (cb.create());
        	RESULT= expresion;
        :}
        
        | TLINT:entero {: 
        	//Comprobaciones semnticas y cdigo intermedio:
        	ScopeIF scope= scopeManager.getCurrentScope();
        	TemporalFactory tf= new TemporalFactory(scope);
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	TemporalIF temp= tf.create();
        	int value=Integer.parseInt(entero.getLexema());
        	cb.addQuadruple("MV", temp, value);
        	Expresion expresion= new Expresion((TypeSimple)scopeManager.searchType("ENTERO"));
        	expresion.setTemporal(temp);
        	expresion.setIntermediateCode(cb.create());
        	RESULT= expresion;
        :}
        
        | TLTRUE {: 
        	//Comprobaciones semnticas y cdigo intermedio:
        	ScopeIF scope= scopeManager.getCurrentScope();
        	TemporalFactory tf= new TemporalFactory(scope);
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	TemporalIF temp= tf.create();
        	cb.addQuadruple("MV", temp, 1);
        	Expresion expresion= new Expresion((TypeSimple)scopeManager.searchType("LOGICO"));
        	expresion.setTemporal(temp);
        	expresion.setIntermediateCode(cb.create());
        	RESULT= expresion;
        :}
        
        | TLFALSE {: 
        	//Comprobaciones semnticas y cdigo intermedio:
        	ScopeIF scope= scopeManager.getCurrentScope();
        	TemporalFactory tf= new TemporalFactory(scope);
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	TemporalIF temp= tf.create();
        	cb.addQuadruple("MV", temp, 0);
        	Expresion expresion= new Expresion((TypeSimple)scopeManager.searchType("LOGICO"));
        	expresion.setTemporal(temp);
        	expresion.setIntermediateCode(cb.create());
        	RESULT= expresion;
        :}
        
        | TIDENTIFICADOR:id {: 
        	//Operaciones y comprobaciones semnticas:
        	OperacionSemantica operacionSemantica= new OperacionSemantica();
        	String nombreID= id.getLexema().toUpperCase();
        	SymbolIF simbolo= operacionSemantica.recuperarSimboloDesdeTablaSimbolos(nombreID, id.getLine());
        	TypeSimple tipoSimbolo= null;
        	TypeFunction tipoFuncion= null;
        	if(simbolo.getType() instanceof TypeFunction){
        		tipoFuncion=(TypeFunction)simbolo.getType();
        		tipoSimbolo=tipoFuncion.getTipoFuncion();
        	}else{
        		if (!(simbolo.getType() instanceof TypeSimple))  operacionSemantica.getErrorSemantico().lanzarErrorPorExpresionConTipoNoPermitido(id.getLine());
        		tipoSimbolo= (TypeSimple)simbolo.getType();
        	}
        	
        	//Cdigo intermedio:
        	ScopeIF scope= scopeManager.getCurrentScope();
        	TemporalFactory tf= new TemporalFactory(scope);
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	TemporalIF temp= tf.create();	
        	TemporalIF temp2= tf.create();
        	if (simbolo instanceof SymbolConstant){
        		int valor= ((SymbolConstant)simbolo).getValor();
        		cb.addQuadruple("MV", temp, valor);
        	}else if(simbolo instanceof SymbolVariable || simbolo instanceof SymbolParameter){
        		Variable var= new Variable(nombreID,simbolo.getScope());
        		cb.addQuadruple("MVA", temp2, var);
        		cb.addQuadruple("MVP", temp, temp2);
        	}
        	else{
        		LabelIF l1= tipoFuncion.getLabel();
	        	cb.addQuadruple("CALL", l1, nombreID);
        	}
        	Expresion expresion= new Expresion(tipoSimbolo);
        	expresion.setTemporal(temp);
        	expresion.setIntermediateCode(cb.create());
        	RESULT= expresion;
        :}
        
        | TIDENTIFICADOR:id1 TPUNTO TIDENTIFICADOR:id2 {:         	
        	//Operaciones y comprobaciones semnticas:
        	String idTipoRegistro= id1.getLexema().toUpperCase();
        	String idRegCampo= id2.getLexema().toUpperCase();
        	OperacionSemantica operacionSemantica= new OperacionSemantica();
        	TypeRecord tipoRegistro= operacionSemantica.recuperarTipoRegistroPorNombreDelSimbolo(idTipoRegistro,id2.getLine());
        	RegCampo regCampo= tipoRegistro.recuperarRegCampoPorNombre(idRegCampo);
        	if (regCampo==null) operacionSemantica.getErrorSemantico().lanzarErrorPorNoExistirRegCampo(id2.getLine());
        	TypeSimple tipoRegCampo= regCampo.getTipoPrimitivoVariable();
        	
        	//Cdigo intermedio:
        	ScopeIF scope= scopeManager.getCurrentScope();
        	TemporalFactory tf= new TemporalFactory(scope);
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	TemporalIF temp= tf.create();
        	TemporalIF temp1= tf.create();
        	int posicion= tipoRegistro.getPosicion(regCampo.getNombreVariable());
        	SymbolIF sV= scopeManager.searchSymbol(idTipoRegistro);
        	Variable var= new Variable(idTipoRegistro, sV.getScope());
        	cb.addQuadruple("MVA", temp1, var, posicion);
        	cb.addQuadruple("MVP", temp, temp1);
        	Expresion expresion= new Expresion(tipoRegCampo);
        	expresion.setTemporal(temp);
        	expresion.setIntermediateCode(cb.create());
        	RESULT= expresion;
        :}  
                                                    
        | TIDENTIFICADOR:id TPARI sentCallParams:param TPARD:tpard {:
        	//Operaciones y comprobaciones semnticas:
        	String idTipoFuncion=id.getLexema().toUpperCase();
        	OperacionSemantica operacionSemantica= new OperacionSemantica();
        	TypeFunction tipoFuncion= operacionSemantica.recuperarTipoFuncionPorNombre(idTipoFuncion, tpard.getLine());
        	tipoFuncion.comprobarCoincidenciaTiposParametros(param.getPilaTipos(), tpard.getLine());
        	SymbolProcedure simboloProcedimiento= (SymbolProcedure) operacionSemantica.recuperarSimboloDesdeTablaSimbolos(idTipoFuncion, tpard.getLine());
        	int numeroParametros=simboloProcedimiento.getSizeParametros();
        	
        	//Cdigo intermedio
        	ScopeIF scope= scopeManager.getCurrentScope();
        	TemporalFactory tf= new TemporalFactory(scope);
        	TemporalIF temp= tf.create();
        	IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	cb.addQuadruples(param.getIntermediateCode());
			LabelIF l1= tipoFuncion.getLabel();
        	cb.addQuadruple("CALL", l1, idTipoFuncion);
        	cb.addQuadruple("RETF", temp , numeroParametros);
        	Expresion expresion= new Expresion(tipoFuncion.getTipoFuncion());
        	expresion.setIntermediateCode(cb.create());
        	expresion.setTemporal(temp);
        	RESULT= expresion;
        :}                                           
        | error
            
    ;


//
// Reglas auxiliares
//

tipoPrimitivo ::=
        TINTEGER {: RESULT = (TypeSimple)scopeManager.searchType("ENTERO"); :}   
        | TBOOLEAN {: RESULT = (TypeSimple)scopeManager.searchType("LOGICO"); :}   
            
    ;

varSeqDeIds ::=
        TIDENTIFICADOR:ti {:
        	//Operaciones y comprobaciones semnticas:
        	VarSeqDeIds varSeqDeIds = new VarSeqDeIds();
        	varSeqDeIds.addNombreVariable(ti.getLexema());
        	RESULT=varSeqDeIds;
        :}
        | TIDENTIFICADOR:ti TCOMA varSeqDeIds:vsqids {:
        	//Operaciones y comprobaciones semnticas:
        	vsqids.addNombreVariable(ti.getLexema());
        	RESULT=vsqids;
        :}  
    ;

cuerpoModulo ::= 
        ctes tipos vars subs:subs TBEGIN finalModulo:fModulo {:
        	//Operaciones y comprobaciones semnticas:
        	String nombreAmbito= scopeManager.getCurrentScope().getName();
        	TypeProcedure tipoProcedimiento=null;
        	if(scopeManager.getCurrentScope().getLevel()!=0){
        		OperacionSemantica operacionSemantica= new OperacionSemantica();
        		tipoProcedimiento=operacionSemantica.recuperarTipoProcedimientoPorNombre(nombreAmbito, fModulo.getNumeroLinea());
        		if (tipoProcedimiento instanceof TypeFunction) {
        			if (!OperacionSemantica.comprobarExisteReturn(fModulo.getSentencias().getPilaSentencias())) operacionSemantica.getErrorSemantico().lanzarErrorPorNoExistirReturn(nombreAmbito);
        		}
        	}
			
			//Cdigo intermedio:
			ScopeIF scope= scopeManager.getCurrentScope();
			IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
        	if(scope.getLevel()!=0){
        		LabelIF l1= tipoProcedimiento.getLabel();
				cb.addQuadruple("INL", l1, scope.getLevel(), scope.getName());
				cb.addQuadruples(fModulo.getSentencias().getIntermediateCode()); //aadir el cdigo intermedio de las diferentes sentencias del subprograma
				if (!(tipoProcedimiento instanceof TypeFunction)) cb.addQuadruple("FIN_SUB");
				scopeManager.closeScope();
				ErrorSemantico errorSemantico= new ErrorSemantico();
				errorSemantico.lanzarInfoCierreAmbito(nombreAmbito,fModulo.getNumeroLinea());
			}else{
				LabelFactory lF= new LabelFactory();
        		LabelIF l1= lF.create();
				cb.addQuadruple("INL", l1, scope.getLevel(), scope.getName());
				cb.addQuadruples(fModulo.getSentencias().getIntermediateCode ());
				cb.addQuadruple("HALT"); 
			}
			fModulo.getSentencias().setIntermediateCode(cb.create());
			RESULT=new CuerpoModulo(subs, fModulo);
		:}
            
        | error
            
    ;

finalModulo ::= 
        sentencias:s TEND TIDENTIFICADOR:id ntPtoComa:pc {: 
        	String nombreModulo=id.getLexema().toUpperCase();
        	RESULT= new FinalModulo(s,nombreModulo,pc); 
        :}
        | error
            
    ;

ntPtoComa ::= //Varios ';' seguidos deben ser interpretados como uno solo.        
        TPTOCOMA:pc {: RESULT= pc.getLine(); :}
        | TPTOCOMA:pc ntPtoComa  {: RESULT= pc.getLine(); :}
    ;
